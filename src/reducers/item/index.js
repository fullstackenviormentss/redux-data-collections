import { combineReducers } from 'redux'
import { handleActions } from 'redux-actions'
import reduceReducers from 'reduce-reducers'
import uuid from 'uuid/v4'
import {
  ITEM_CREATE_NEW,
  ITEM_ADD,
  ITEM_SAVE
} from '../../constants/item'
import {
  ITEM_ATTRIBUTES_ROLLBACK,
  ITEM_ATTRIBUTE_TOGGLE
} from '../../constants/attributes'
import attributesReducer from '../attributes'
import relationshipsReducer from '../relationships'
import metaReducer from './metaReducer'

const identityReducer = (initialState = {}) => (state = initialState) => state

const itemReducer = handleActions({
  [ITEM_CREATE_NEW]: (state, action) => {
    const { payload, meta } = action
    const { data } = payload
    const { type } = meta
    const item = { ...data, meta: data.meta || {} }

    item.meta.isNew = true

    if (!item.id) {
      item.id = uuid()
      item.meta.hasAutogeneratedId = true
    }

    if (!item.type) {
      item.type = type
    }

    return item
  },

  [ITEM_ADD]: (state, action) => {
    const { payload } = action
    const { type, data } = payload
    const item = { ...state, ...data, meta: { ...state.meta, ...data.meta } }

    item.meta.isLoaded = true

    if (!item.id) {
      item.id = uuid()
      item.meta.hasAutogeneratedId = true
    }

    if (!item.type) {
      item.type = type
    }

    return item
  },

  // TODO: save should really be happening in the middleware
  [ITEM_SAVE]: (state, action) => {
    const { changedAttributes } = state.meta
    const item = {
      ...state,
      attributes: { ...state.attributes, ...changedAttributes }
    }

    return item
  },
  [ITEM_ATTRIBUTES_ROLLBACK]: (state, action) => {
    const { meta } = state || {}
    const { changedAttributes, deletedAttributes } = meta
    const hasChangedAttributes = !!changedAttributes && !!Object.keys(changedAttributes).length
    const hasDeletedAttributes = !!deletedAttributes && !!deletedAttributes.length
    const newState = { ...state }
    if (hasChangedAttributes) {
      delete newState.meta.changedAttributes
    }
    if (hasDeletedAttributes) {
      delete newState.meta.deletedAttributes
    }
    newState.meta.isSaved = true

    return newState
  },
  [ITEM_ATTRIBUTE_TOGGLE]: (state, action) => {
    const { payload } = action
    const { key } = payload
    const value = state.attributes[key]

    const newAction = {
      ...action,
      meta: { ...action.meta, value }
    }
    return { ...state, meta: metaReducer(state.meta, newAction) }
  }
}, {})

// wraps a reducer, skips actions in the constants array
const skipActions = (constants = []) => reducer => (state, action) => {
  if (!constants.includes(action.type)) {
    return reducer(state, action)
  }
  return state
}

export default (state, action) => {
  const { payload, meta } = action
  const { type, options } = meta || {}
  if (!payload) { return state }

  return reduceReducers(
    itemReducer,
    combineReducers({
      type: identityReducer(type),
      id: identityReducer(''),
      attributes: attributesReducer(options),
      relationships: relationshipsReducer(options),
      meta: skipActions([ITEM_ATTRIBUTE_TOGGLE])(metaReducer)
    })
  )(state, action)
}
