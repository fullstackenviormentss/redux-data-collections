import { combineReducers } from 'redux'
import { handleActions } from 'redux-actions'
import reduceReducers from 'reduce-reducers'
import uuid from '../../utils/uuid'
import {
  ITEM_CREATE_NEW,
  ITEM_ADD,
  ITEM_LOAD,
  ITEM_COMMIT
} from '../../constants/item'
import {
  ITEM_ATTRIBUTES_ROLLBACK,
  ITEM_ATTRIBUTE_TOGGLE
} from '../../constants/attributes'
import { selectType, selectId, selectData, selectKey, selectOptions } from '../../selectors/action'
import createAttributesReducer from '../attributes'
import createRelationshipsReducer from '../relationships'
import metaReducer from './metaReducer'
import get from 'lodash.get'

const identityReducer = (initialState = {}) => (state = initialState) => state

const itemReducer = handleActions({
  [ITEM_CREATE_NEW]: (state, action) => {
    const type = selectType(action)
    const id = selectId(action)
    const data = selectData(action)
    const item = { ...data, meta: data.meta || {} }
    if (!item.id) {
      item.id = id || uuid()
      item.meta.hasAutogeneratedId = true
    }
    if (!item.type) { item.type = type }
    item.meta.isNew = true
    return item
  },

  [ITEM_ADD]: (state, action) => {
    const type = selectType(action)
    const id = selectId(action)
    const data = selectData(action)
    const item = { ...state, ...data, meta: { ...state.meta, ...get(data, 'meta') } }
    if (!item.id) {
      item.id = id || uuid()
      item.meta.hasAutogeneratedId = true
    }
    if (!item.type) { item.type = type }
    return item
  },
  [ITEM_LOAD]: (state, action) => {
    // TODO: functionally identical to add
    const type = selectType(action)
    const id = selectId(action)
    const data = selectData(action)
    const item = { ...state, ...data, meta: { ...state.meta, ...get(data, 'meta') } }
    if (!item.id) {
      item.id = id || uuid()
      item.meta.hasAutogeneratedId = true
    }
    if (!item.type) { item.type = type }
    item.meta.isLoaded = true
    return item
  },
  [ITEM_COMMIT]: (state, action) => {
    const { changedAttributes } = state.meta
    const item = {
      ...state,
      attributes: { ...state.attributes, ...changedAttributes }
      // relationships are handled by a separate reducer
    }

    return item
  },
  [ITEM_ATTRIBUTES_ROLLBACK]: (state, action) => {
    const { changedAttributes, deletedAttributes } = get(state, 'meta', {})
    const hasChangedAttributes = !!changedAttributes && !!Object.keys(changedAttributes).length
    const hasDeletedAttributes = !!deletedAttributes && !!deletedAttributes.length
    const newState = { ...state }
    if (hasChangedAttributes) {
      delete newState.meta.changedAttributes
    }
    if (hasDeletedAttributes) {
      delete newState.meta.deletedAttributes
    }
    newState.meta.isSaved = true

    return newState
  },
  [ITEM_ATTRIBUTE_TOGGLE]: (state, action) => {
    const key = selectKey(action)
    const value = state.attributes[key]

    const newAction = {
      ...action,
      meta: { ...action.meta, value }
    }
    return { ...state, meta: metaReducer(state.meta, newAction) }
  }
}, {})

// wraps a reducer, skips actions in the constants array
const skipActions = (constants = []) => reducer => (state, action) => {
  if (!constants.includes(action.type)) {
    return reducer(state, action)
  }
  return state
}

export default (state, action) => {
  const type = selectType(action)
  const options = selectOptions(action)
  if (!type) { return state }
  return reduceReducers(
    itemReducer,
    combineReducers({
      type: identityReducer(type),
      id: identityReducer(''),
      attributes: createAttributesReducer(options),
      relationships: createRelationshipsReducer(options),
      meta: skipActions([ITEM_ATTRIBUTE_TOGGLE])(metaReducer)
    })
  )(state, action)
}
